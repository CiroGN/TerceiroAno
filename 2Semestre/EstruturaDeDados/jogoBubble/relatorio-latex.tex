\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[top=2.5cm,bottom=2.5cm,left=2cm,right=2cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage{booktabs}
\usepackage{float}
\usepackage{tikz}

% Configuração de código
\lstset{
    language=JavaScript,
    basicstyle=\ttfamily\small,
    breaklines=true,
    commentstyle=\color{gray},
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    showstringspaces=false,
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    frame=single,
    rulecolor=\color{black!30},
    backgroundcolor=\color{white}
}

% Header e Footer
\pagestyle{fancy}
\fancyhf{}
\rhead{IFPR - BCC-3}
\lhead{Bubble Sort Game}
\cfoot{\thepage}

% Espaçamento
\onehalfspacing

% Cores customizadas
\definecolor{darkblue}{RGB}{0,51,102}
\definecolor{lightblue}{RGB}{200,220,255}

\title{\textcolor{darkblue}{\textbf{JOGO EDUCATIVO DE ORDENAÇÃO}\\[0.5cm]}}

\author{\textbf{Instituto Federal do Paraná - IFPR} \\ Alexandre Raphael Marques De Freitas \\ Ciro Guilherme Nass \\ Luan Mickael da Rocha \\ Miguel Martins Costa \\ Nicolas Lourenço Dos Santos\\\\Curso: Bacharelado em Ciência da Computação\\Disciplina: Estrutura de Dados\\Professor: Marcelo Maia\\Turma: BCC-3}
\date{Novembro de 2025}

\begin{document}

% Página de Título
\maketitle
\thispagestyle{empty}

\vfill

\begin{center}
    \textbf{\textcolor{darkblue}{Resumo Executivo}}
\end{center}

\noindent
Este relatório apresenta o desenvolvimento de um jogo educativo interativo para o ensino do algoritmo de ordenação Bubble Sort. O projeto foi desenvolvido utilizando tecnologias web (HTML5, CSS3 e JavaScript), proporcionando uma experiência de aprendizagem prática e engajante para alunos de Estrutura de Dados.

O jogo implementa um sistema de validação de passos que verifica se o jogador executa as trocas de elementos corretas segundo o algoritmo bubble sort, com sistema de vidas e feedback em tempo real. A interface gráfica intuitiva facilita o entendimento do funcionamento do algoritmo através da prática.

\vspace{1cm}
\noindent
\textbf{Palavras-chave:} Algoritmo Bubble Sort, Jogo Educativo, Estrutura de Dados, HTML5, JavaScript, Aprendizagem Interativa.

\newpage

% Índice
\tableofcontents
\newpage

% Seção 1
\section{Introdução}

\subsection{Contextualização}

A compreensão de algoritmos de ordenação é fundamental para a formação de um cientista da computação. Porém, o aprendizado teórico frequentemente carece do engajamento do aluno. Métodos tradicionais, como aulas expositivas e listas de exercícios, nem sempre são suficientes para manter o interesse e promover aprendizagem profunda.

A gamificação de conceitos educacionais é uma estratégia comprovadamente eficaz para aumentar engajamento e retenção de conhecimento. Este projeto explora essa abordagem ao criar um jogo interativo onde o aluno não apenas observa o algoritmo em funcionamento, mas participa ativamente de sua execução.

\subsection{Objetivo Geral}

Desenvolver um aplicativo educativo web-based que permita aos alunos da disciplina de Estrutura de Dados compreender e praticar o algoritmo Bubble Sort através de um jogo interativo com validação de passos corretos.

\subsection{Objetivos Específicos}

\begin{itemize}
    \item Implementar validação automática das trocas de elementos efetuadas pelo jogador
    \item Fornecer feedback visual e de texto em tempo real
    \item Criar interface amigável e intuitiva que promova engajamento
    \item Facilitar expansão futura para outros algoritmos de ordenação
\end{itemize}

% Seção 2
\section{Fundamentação Teórica}

\subsection{Algoritmo Bubble Sort}

O Bubble Sort é um algoritmo de ordenação simples que funciona repetidamente percorrendo a lista, comparando elementos adjacentes e trocando-os se estiverem na ordem errada. O algoritmo recebe seu nome porque elementos menores ``borbulham'' para o topo da lista.

\subsubsection{Funcionamento Básico}

\begin{lstlisting}
Para i = 0 até n-1:
    Para j = 0 até n-i-2:
        Se array[j] > array[j+1]:
            Trocar array[j] com array[j+1]
\end{lstlisting}

\subsubsection{Características}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Propriedade} & \textbf{Valor} \\
        \hline
        Complexidade Temporal (pior caso) & $O(n^2)$ \\
        Complexidade Temporal (melhor caso) & $O(n)$ \\
        Estável & Sim \\
        In-place & Sim \\
        \hline
    \end{tabular}
    \caption{Características do Algoritmo Bubble Sort}
\end{table}

\subsection{Motivação Pedagógica}

O Bubble Sort é ideal para fins educacionais por:

\begin{enumerate}
    \item Ser conceitualmente simples
    \item Facilitar compreensão visual de como comparações e trocas funcionam
    \item Servir como base para entender algoritmos mais complexos
    \item Permitir análise clara de desempenho
\end{enumerate}

% Seção 3
\section{Arquitetura do Sistema}

\subsection{Visão Geral}

O aplicativo segue uma arquitetura de cliente (frontend) única, sem necessidade de servidor backend. A estrutura compreende três componentes principais:

\begin{enumerate}
    \item \textbf{HTML5} - Estrutura e semântica do documento
    \item \textbf{CSS3} - Apresentação visual e responsividade
    \item \textbf{JavaScript (ES6+)} - Lógica de jogo e interatividade
\end{enumerate}

\subsection{Estrutura de Dados}

\subsubsection{Variáveis de Estado Principal}

\begin{lstlisting}
gameState = {
    initialArray: [],           // Array embaralhado inicial
    playerArray: [],            // Array que o jogador está ordenando
    referenceArray: [],         // Array totalmente ordenado
    referenceSteps: [],         // Todos os passos corretos do algoritmo
    currentStep: 0,             // Índice do passo atual
    lives: 3,                   // Vidas restantes
    arraySize: 5,               // Tamanho selecionado (5, 8, 10)
    isGameOver: false,          // Flag de fim de jogo
    isWon: false,               // Flag de vitória
    totalMoves: 0,              // Total de movimentos feitos
    correctMoves: 0,            // Movimentos corretos
    hintsUsed: 0,               // Dicas utilizadas
    selectedIndices: [],        // Índices selecionados pelo jogador
    currentReferenceStep: 0     // Passo atual da referência
}
\end{lstlisting}

\subsubsection{Justificativa da Escolha de Arrays}

Arrays foram escolhidos porque:

\begin{itemize}
    \item \textbf{Simplicidade:} Melhor alinha com o conceito educativo
    \item \textbf{Performance:} Acesso direto aos elementos por índice
    \item \textbf{Visualização:} Representação visual clara e intuitiva
    \item \textbf{Alinhamento com Bubble Sort:} O algoritmo trabalha naturalmente com arrays
\end{itemize}

% Seção 4
\section{Decisões Técnicas}


\subsection{Estrutura do Projeto}

\begin{verbatim}
bubble-sort-game/
- index.html        # Estrutura HTML e layout
- style.css         # Estilos e tema visual
- script.js         # Lógica do jogo
- README.md         # Documentação
\end{verbatim}

\textbf{Vantagem do arquivo único:} Facilita distribuição e hospedagem em GitHub Pages.

% Seção 5
\section{Implementação Detalhada}

\subsection{Fluxo Principal do Jogo}

O jogo segue uma sequência bem definida de estados, começando pela tela inicial, passando pela seleção de dificuldade, até o loop principal do jogo e, finalmente, a tela de resultados.

\subsubsection{Geração do Array Embaralhado}

\begin{lstlisting}
function generateShuffledArray(size) {
    // 1. Cria array com valores únicos de 0 a 10
    // 2. Aplica algoritmo Fisher-Yates para embaralhamento
    // 3. Retorna array shuffled
}
\end{lstlisting}

\textbf{Algoritmo Fisher-Yates:}
\begin{itemize}
    \item Garante distribuição uniforme de permutações
    \item Complexidade: $O(n)$
    \item Mais eficiente que naive shuffle
\end{itemize}

\subsubsection{Geração dos Passos do Bubble Sort}

\begin{lstlisting}
function generateBubbleSortSteps(array) {
    // 1. Executa bubble sort enquanto rastreia cada estado
    // 2. Armazena snapshot após cada swap
    // 3. Retorna array de todos os estados intermediários
}
\end{lstlisting}

\textbf{Benefício:} Permite validação precisa de qualquer movimento do jogador contra a sequência correta.

\subsubsection{Validação de Movimento}

\begin{lstlisting}
function isValidSwap(expectedArray, playerArray, pos1, pos2) {
    // 1. Cria cópia do array do jogador
    // 2. Realiza swap nas posições
    // 3. Compara com próximo passo esperado
    // 4. Retorna true se match, false caso contrário
}
\end{lstlisting}

\textbf{Lógica de Validação:}
\begin{itemize}
    \item O jogo não valida se a troca é ``boa em geral''
    \item Valida se é o \textbf{próximo passo correto} específico
    \item Isto força o jogador a seguir o algoritmo passo-a-passo
\end{itemize}

\subsection{Sistema de Vidas}

\begin{itemize}
    \item Começa com \textbf{3 vidas}
    \item Perde \textbf{1 vida} a cada erro
    \item \textbf{Game Over} quando vidas = 0
    \item Feedback visual imediato ao perder vida
\end{itemize}

% Seção 6
\section{Análise de Qualidade}

\subsection{Validação e Testes}

\subsubsection{Testes Funcionais}

\begin{table}[H]
    \centering
    \small
    \begin{tabular}{|l|p{3cm}|p{3cm}|c|}
        \hline
        \textbf{Caso} & \textbf{Entrada} & \textbf{Esperado} & \textbf{Status} \\
        \hline
        Swap correto & Posições 0,1 em \{6,2,...\} & Troca validada & ✓ \\
        \hline
        Swap errado & Posições 0,1 quando não deve & Erro, perde vida & ✓ \\
        \hline
        Vitória & Array completamente ordenado & Tela de vitória & ✓ \\
        \hline
        Game Over & Vidas = 0 & Tela de derrota & ✓ \\
        \hline
        Dica & Clica em ``Dica'' & Mostra próximo swap & ✓ \\
        \hline
    \end{tabular}
    \caption{Testes Funcionais do Jogo}
\end{table}

\subsection{Performance}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|r|c|}
        \hline
        \textbf{Métrica} & \textbf{Valor} & \textbf{Status} \\
        \hline
        Tempo de carregamento & $< 500\text{ms}$ & ✓ \\
        \hline
        Geração de array (10 elem.) & $< 10\text{ms}$ & ✓ \\
        \hline
        Validação de swap & $< 5\text{ms}$ & ✓ \\
        \hline
        Renderização de tela & $< 16\text{ms}$ & ✓ \\
        \hline
    \end{tabular}
    \caption{Métricas de Performance}
\end{table}

% Seção 7
\section{Expansibilidade}

\subsection{Adição de Novos Algoritmos}

O código foi estruturado para facilitar adição de outros algoritmos:

\begin{lstlisting}
function generateInsertionSortSteps(array) {
    // Implementar insertion sort com rastreamento de passos
}

function generateQuickSortSteps(array) {
    // Implementar quick sort com rastreamento de passos
}
\end{lstlisting}

\textbf{Mudanças necessárias:}
\begin{enumerate}
    \item Criar função \texttt{generateXxxSortSteps()} para novo algoritmo
    \item Adicionar opção de seleção na tela inicial
    \item Adicionar explicação do algoritmo na seção ``Como Jogar''
\end{enumerate}

\subsection{Melhorias Futuras}

\begin{itemize}
    \item \textbf{Leaderboard:} Armazenar scores em localStorage
    \item \textbf{Modo Competitivo:} Multiplayer (dois jogadores simultâneos)
    \item \textbf{Temas Personalizados:} Diferentes visuais
    \item \textbf{Modo Automático:} Ver algoritmo resolver antes de jogar
    \item \textbf{Análise Detalhada:} Gráficos de comparações e trocas
    \item \textbf{Suporte a Mobile:} Toque em vez de clique
\end{itemize}

% Seção 9
\section{Conclusões}

Este projeto demonstrou a viabilidade e efetividade de gamificação para ensino de algoritmos de estrutura de dados. A escolha de tecnologias web proporcionou:

\begin{enumerate}
    \item \textbf{Interface Rica:} Visualização clara do algoritmo
    \item \textbf{Engajamento:} Mecânica de jogo motiva aprendizado
    \item \textbf{Acessibilidade:} Fácil compartilhamento e acesso
    \item \textbf{Manutenibilidade:} Código simples e extensível
    \item \textbf{Escalabilidade:} Preparado para novos algoritmos
\end{enumerate}

O jogo cumpre seu objetivo de permitir que alunos pratiquem e compreendam o algoritmo Bubble Sort de forma interativa e lúdica.

% Seção 10
\section{Trabalhos Futuros}

\begin{itemize}
    \item Implementar Selection Sort, Insertion Sort, e Quick Sort
    \item Adicionar visualização animada do algoritmo
    \item Criar versão mobile nativa (React Native)
    \item Integrar com plataforma de aprendizagem (Moodle)
    \item Adicionar sistema de challenges com rankings
    \item Expandir para 50+ algoritmos diferentes
\end{itemize}

% Referências
\begin{thebibliography}{99}

\bibitem{cormen2009}
Cormen, T. H., Leiserson, C. E., Rivest, R. L., \& Stein, C. (2009).
\textit{Introduction to algorithms} (3rd ed.). MIT Press.

\bibitem{knuth1998}
Knuth, D. E. (1998).
\textit{The art of computer programming: Volume 3 - Sorting and searching} (2nd ed.). Addison-Wesley.

\bibitem{w3c2023}
W3C. (2023).
HTML Living Standard. Retrieved from https://html.spec.whatwg.org/

\bibitem{mdn2023}
MDN Web Docs. (2023).
JavaScript Reference. Retrieved from https://developer.mozilla.org/en-US/docs/Web/JavaScript

\bibitem{papert1980}
Papert, S. (1980).
\textit{Mindstorms: Children, computers, and powerful ideas}. Basic Books.

\bibitem{prensky2007}
Prensky, M. (2007).
Digital game-based learning. \textit{Computers in Entertainment}, 5(1), 21.

\end{thebibliography}

\end{document}